dim(x)<-c(length(x),1)
}
n <- nrow(x)
g <- max(clall[,1])
Hart <- (wgss(x,clall[,1],d,centrotypes)/wgss(x,clall[,2],d,centrotypes)-1)*(n-g-1)
return(list(Hart = Hart, wgss1 = wgss(x,clall[,1],d,centrotypes), wgss2 = wgss(x,clall[,2],d,centrotypes)))
}
Hart <- do.call(rbind, lapply(1:(ncol(clust.mat) - 1), function(k)
index.H(Xt, cbind(clust.mat[, k], clust.mat[, k + 1]))))
Hart
Hart <- rbind(Hart, NA)
Hart
CalcCVIsForAll <- function(Xt, hp.vals, clust.mat, methods = c("Sil", "DB", "DBstar", "Gap", "Hart"), hp.name = "K.init"){
index.mat <- cbind(hp = hp.vals)
colnames(index.mat) <- hp.name
if ("DB" %in% methods){
DB <- apply(clust.mat, 2, function(Cs) index.DB(Xt, Cs, p=2,q=1)$DB)
index.mat <- cbind(index.mat, DB)
}
if ("DBstar" %in% methods){
DBstar <- apply(clust.mat, 2, function(Cs) index.DBstar(Xt, Cs))
index.mat <- cbind(index.mat, DBstar)
}
if ("Sil" %in% methods){
dist.Xt <- dist(Xt)
Sil <- apply(clust.mat, 2, function(Cs) index.S(dist.Xt, Cs))
index.mat <- cbind(index.mat, Sil)
}
if ("Gap" %in% methods){
if (ncol(clust.mat) == 1){
stop("Gap statistic requires more than one hp value")
} else {
Gap.stats <- do.call(rbind, lapply(1:(ncol(clust.mat) - 1), function(k)
index.Gap(Xt, cbind(clust.mat[, k], clust.mat[, k + 1]), method = "centroid")))
Gap.stats <- rbind(Gap.stats,
index.Gap(Xt, cbind(clust.mat[, ncol(clust.mat)], clust.mat[, ncol(clust.mat)]), method = "centroid"))
index.mat <- cbind(index.mat, Gap.stats)
}
}
if ("Hart" %in% methods){
Hart <- do.call(rbind, lapply(1:(ncol(clust.mat) - 1), function(k)
index.H(Xt, cbind(clust.mat[, k], clust.mat[, k + 1]))))
Hart <- rbind(Hart, NA)
index.mat <- cbind(index.mat, Hart)
}
}
GetBestHPSingleIndex <- function(index.mat, CVI.name = "Sil", decision.rule = "MaxInc", hp.name = "K.init"){
# Decision rules for DB, DBstar and Hart: "MaxDec" and "Min"
# Decision rules for Sil: "MaxInc" and "Max"
# Decision rules for Gap: "MaxInc" and "Gap"
hp.vals <- index.mat[, hp.name]
index.vals <- index.mat[, CVI.name]
if (decision.rule == "MaxInc"){
if (CVI.name %in% c("DB", "DBstar", "Hart")){
stop(paste0("MaxInc is not recommended for ", CVI.name))
} else {
best.hp <- BestMaxInc(index.vals, hp.vals)
}
}
if (decision.rule == "MaxDec"){
if (CVI.name %in% c("Sil", "Gap")){
stop(paste0("MaxDec is not recommended for ", CVI.name))
} else {
best.hp <- BestMaxDec(index.vals, hp.vals)
}
}
if (decision.rule == "Max"){
if (CVI.name %in% c("DB", "DBstar", "Hart")){
stop(paste0(CVI.name, " should not be maximized"))
} else {
best.hp <- hp.vals[which.max(index.vals)]
}
}
if (decision.rule == "Min"){
if (CVI.name %in% c("Sil", "Gap")){
stop(paste0(CVI.name, " should not be minimized"))
} else {
best.hp <- hp.vals[which.min(index.vals)]
}
}
if (decision.rule == "Gap"){
if (CVI.name != "Gap"){
stop("The Gap rule can only be used with the Gap CVI")
} else {
best.hp <- hp.vals[which(index.mat[, "diffu"]>=0)[1]]
}
}
decision <- cbind.data.frame(best.hp = best.hp,
CVI.name = CVI.name,
decision.rule = decision.rule,
index.val = index.vals[which(hp.vals == best.hp)],
diffu = NA,
sd = NA)
if (CVI.name == "Gap"){
decision$diffu <- index.mat[which(hp.vals == best.hp), "diffu"]
decision$sd <- index.mat[which(hp.vals == best.hp), "sdgap1"]
}
colnames(decision)[1] <- hp.name
return(decision)
}
decision.mat <- do.call(rbind, lapply(1:length(CVI.methods), function(CVI.index)
GetBestHPSingleIndex(index.mat,
CVI.name = CVI.methods[CVI.index],
decision.rule = decision.rules[CVI.index],
hp.name = "prop.eta.max")))
decision.mat
decision.rules = c("Max", "Min", "Min", "MaxInc", "MaxDec")
decision.mat <- do.call(rbind, lapply(1:length(CVI.methods), function(CVI.index)
GetBestHPSingleIndex(index.mat,
CVI.name = CVI.methods[CVI.index],
decision.rule = decision.rules[CVI.index],
hp.name = "prop.eta.max")))
decision.mat
cbind.data.frame(K.init = K.vals[K.index], decision.mat)
K.vals <- sort(unique(res.AdaCLV$hp[, "K.init"]))
n.K <- length(K.vals)
decisions.by.K <- list()
for (K.index in 1:n.K){
wh <- which(res.AdaCLV$hp[, "K.init"] == K.vals[K.index])
clust.mat <- sapply(wh, function(x) GetHardClusters(res.AdaCLV$output[[x]]$S))
prop.vals.eta.max <- sort(res.AdaCLV$hp[wh, "prop.eta.max"])
index.mat <- CalcCVIsForAll(Xt, prop.vals.eta.max, clust.mat, CVI.methods, hp.name = "prop.eta.max")
decision.mat <- do.call(rbind, lapply(1:length(CVI.methods), function(CVI.index)
GetBestHPSingleIndex(index.mat,
CVI.name = CVI.methods[CVI.index],
decision.rule = decision.rules[CVI.index],
hp.name = "prop.eta.max")))
decisions.by.K[[K.index]] <- cbind.data.frame(K.init = K.vals[K.index], decision.mat)
}
index.mat <- CalcCVIsForAll(Xt, prop.vals.eta.max, clust.mat, CVI.methods, hp.name = "prop.eta.max")
decision.mat <- do.call(rbind, lapply(1:length(CVI.methods), function(CVI.index)
GetBestHPSingleIndex(index.mat,
CVI.name = CVI.methods[CVI.index],
decision.rule = decision.rules[CVI.index],
hp.name = "prop.eta.max")))
hp.vals <- index.mat[, hp.name]
index.vals <- index.mat[, CVI.name]
if (decision.rule == "MaxInc"){
if (CVI.name %in% c("DB", "DBstar", "Hart")){
stop(paste0("MaxInc is not recommended for ", CVI.name))
} else {
best.hp <- BestMaxInc(index.vals, hp.vals)
}
}
if (decision.rule == "MaxDec"){
if (CVI.name %in% c("Sil", "Gap")){
stop(paste0("MaxDec is not recommended for ", CVI.name))
} else {
best.hp <- BestMaxDec(index.vals, hp.vals)
}
}
if (decision.rule == "Max"){
if (CVI.name %in% c("DB", "DBstar", "Hart")){
stop(paste0(CVI.name, " should not be maximized"))
} else {
best.hp <- hp.vals[which.max(index.vals)]
}
}
if (decision.rule == "Min"){
if (CVI.name %in% c("Sil", "Gap")){
stop(paste0(CVI.name, " should not be minimized"))
} else {
best.hp <- hp.vals[which.min(index.vals)]
}
}
if (decision.rule == "Gap"){
if (CVI.name != "Gap"){
stop("The Gap rule can only be used with the Gap CVI")
} else {
best.hp <- hp.vals[which(index.mat[, "diffu"]>=0)[1]]
}
}
decision <- cbind.data.frame(best.hp = best.hp,
CVI.name = CVI.name,
decision.rule = decision.rule,
index.val = index.vals[which(hp.vals == best.hp)],
diffu = NA,
sd = NA)
if (CVI.name == "Gap"){
decision$diffu <- index.mat[which(hp.vals == best.hp), "diffu"]
decision$sd <- index.mat[which(hp.vals == best.hp), "sdgap1"]
}
colnames(decision)[1] <- hp.name
decision.rules
CVI.methods
GetBestHPSingleIndex <- function(index.mat, CVI.name = "Sil", decision.rule = "MaxInc", hp.name = "K.init"){
# Decision rules for DB, DBstar and Hart: "MaxDec" and "Min"
# Decision rules for Sil: "MaxInc" and "Max"
# Decision rules for Gap: "MaxInc" and "Gap"
hp.vals <- index.mat[, hp.name]
index.vals <- index.mat[, CVI.name]
if (decision.rule == "MaxInc"){
if (CVI.name %in% c("DB", "DBstar", "Hart")){
stop(paste0("MaxInc is not recommended for ", CVI.name))
} else {
best.hp <- BestMaxInc(index.vals, hp.vals)
}
}
if (decision.rule == "MaxDec"){
if (CVI.name %in% c("Sil", "Gap")){
stop(paste0("MaxDec is not recommended for ", CVI.name))
} else {
best.hp <- BestMaxDec(index.vals, hp.vals)
}
}
if (decision.rule == "Max"){
if (CVI.name %in% c("DB", "DBstar", "Hart")){
stop(paste0(CVI.name, " should not be maximized"))
} else {
best.hp <- hp.vals[which.max(index.vals)]
}
}
if (decision.rule == "Min"){
if (CVI.name %in% c("Sil", "Gap")){
stop(paste0(CVI.name, " should not be minimized"))
} else {
best.hp <- hp.vals[which.min(index.vals)]
}
}
if (decision.rule == "Gap"){
if (CVI.name != "Gap"){
stop("The Gap rule can only be used with the Gap CVI")
} else {
best.hp <- hp.vals[which(index.mat[, "diffu"]>=0)[1]]
}
}
decision <- cbind.data.frame(best.hp = best.hp,
CVI.name = CVI.name,
decision.rule = decision.rule,
index.val = index.vals[which(hp.vals == best.hp)],
diffu = NA,
sd = NA)
if (CVI.name == "Gap"){
decision$diffu <- index.mat[which(hp.vals == best.hp), "diffu"]
decision$sd <- index.mat[which(hp.vals == best.hp), "sdgap1"]
}
colnames(decision)[1] <- hp.name
return(decision)
}
for (K.index in 1:n.K){
wh <- which(res.AdaCLV$hp[, "K.init"] == K.vals[K.index])
clust.mat <- sapply(wh, function(x) GetHardClusters(res.AdaCLV$output[[x]]$S))
prop.vals.eta.max <- sort(res.AdaCLV$hp[wh, "prop.eta.max"])
index.mat <- CalcCVIsForAll(Xt, prop.vals.eta.max, clust.mat, CVI.methods, hp.name = "prop.eta.max")
decision.mat <- do.call(rbind, lapply(1:length(CVI.methods), function(CVI.index)
GetBestHPSingleIndex(index.mat,
CVI.name = CVI.methods[CVI.index],
decision.rule = decision.rules[CVI.index],
hp.name = "prop.eta.max")))
decisions.by.K[[K.index]] <- cbind.data.frame(K.init = K.vals[K.index], decision.mat)
}
for (CVI.index in 1:length(CVI.methods)){
GetBestHPSingleIndex(index.mat,
CVI.name = CVI.methods[CVI.index],
decision.rule = decision.rules[CVI.index],
hp.name = "prop.eta.max")
}
CVI.index
CVI.name = CVI.methods[CVI.index]
decision.rule = decision.rules[CVI.index]
hp.name = "prop.eta.max"
hp.vals <- index.mat[, hp.name]
index.vals <- index.mat[, CVI.name]
if (decision.rule == "MaxInc"){
if (CVI.name %in% c("DB", "DBstar", "Hart")){
stop(paste0("MaxInc is not recommended for ", CVI.name))
} else {
best.hp <- BestMaxInc(index.vals, hp.vals)
}
}
if (decision.rule == "MaxDec"){
if (CVI.name %in% c("Sil", "Gap")){
stop(paste0("MaxDec is not recommended for ", CVI.name))
} else {
best.hp <- BestMaxDec(index.vals, hp.vals)
}
}
if (decision.rule == "Max"){
if (CVI.name %in% c("DB", "DBstar", "Hart")){
stop(paste0(CVI.name, " should not be maximized"))
} else {
best.hp <- hp.vals[which.max(index.vals)]
}
}
if (decision.rule == "Min"){
if (CVI.name %in% c("Sil", "Gap")){
stop(paste0(CVI.name, " should not be minimized"))
} else {
best.hp <- hp.vals[which.min(index.vals)]
}
}
if (decision.rule == "Gap"){
if (CVI.name != "Gap"){
stop("The Gap rule can only be used with the Gap CVI")
} else {
best.hp <- hp.vals[which(index.mat[, "diffu"]>=0)[1]]
}
}
decision <- cbind.data.frame(best.hp = best.hp,
CVI.name = CVI.name,
decision.rule = decision.rule,
index.val = index.vals[which(hp.vals == best.hp)],
diffu = NA,
sd = NA)
index.vals
index.mat[, hp.name]
hp.name
index.mat[, CVI.name]
CalcCVIsForAll <- function(Xt, hp.vals, clust.mat, methods = c("Sil", "DB", "DBstar", "Gap", "Hart"), hp.name = "K.init"){
index.mat <- cbind(hp = hp.vals)
colnames(index.mat) <- hp.name
if ("DB" %in% methods){
DB <- apply(clust.mat, 2, function(Cs) index.DB(Xt, Cs, p=2,q=1)$DB)
index.mat <- cbind(index.mat, DB)
}
if ("DBstar" %in% methods){
DBstar <- apply(clust.mat, 2, function(Cs) index.DBstar(Xt, Cs))
index.mat <- cbind(index.mat, DBstar)
}
if ("Sil" %in% methods){
dist.Xt <- dist(Xt)
Sil <- apply(clust.mat, 2, function(Cs) index.S(dist.Xt, Cs))
index.mat <- cbind(index.mat, Sil)
}
if ("Gap" %in% methods){
if (ncol(clust.mat) == 1){
stop("Gap statistic requires more than one hp value")
} else {
Gap.stats <- do.call(rbind, lapply(1:(ncol(clust.mat) - 1), function(k)
index.Gap(Xt, cbind(clust.mat[, k], clust.mat[, k + 1]), method = "centroid")))
Gap.stats <- rbind(Gap.stats,
index.Gap(Xt, cbind(clust.mat[, ncol(clust.mat)], clust.mat[, ncol(clust.mat)]), method = "centroid"))
index.mat <- cbind(index.mat, Gap.stats)
}
}
if ("Hart" %in% methods){
Hart <- do.call(rbind, lapply(1:(ncol(clust.mat) - 1), function(k)
index.H(Xt, cbind(clust.mat[, k], clust.mat[, k + 1]))))
Hart <- rbind(Hart, NA)
index.mat <- cbind(index.mat, Hart)
}
return(index.mat)
}
index.mat <- CalcCVIsForAll(Xt, prop.vals.eta.max, clust.mat, CVI.methods, hp.name = "prop.eta.max")
index.mat
decision.mat <- do.call(rbind, lapply(1:length(CVI.methods), function(CVI.index)
GetBestHPSingleIndex(index.mat,
CVI.name = CVI.methods[CVI.index],
decision.rule = decision.rules[CVI.index],
hp.name = "prop.eta.max")))
# From cslusterSim package
index.H<-function(x,clall,d=NULL,centrotypes="centroids")
{
wgss<-function(x,cl,d,centroids)
{
n <- length(cl)
k <- max(cl)
if(is.null(dim(x))){
dim(x)<-c(length(x),1)
}
centers<-matrix(nrow=k,ncol=ncol(x))
for(i in 1:k){
if(centrotypes=="centroids"){
if(ncol(x)==1){
centers[i,]<-mean(x[cl==i,])
}
else{
if(is.null(dim(x[cl==i,]))){
centers[i,]<-x[cl==i]
}
else{
centers[i,]<-apply(x[cl==i,],2,mean)
}
}
}
else{
centers[i,]<-.medoid(x[cl==i,],d[cl==i,cl==i])
}
}
withins <- rep(0, k)
x <- (x - centers[cl,])^2
for(i in 1:k){
withins[i] <- sum(x[cl==i,])
}
sum(withins)
}
if(sum(c("centroids","medoids")==centrotypes)==0)
stop("Wrong centrotypes argument")
if("medoids"==centrotypes && is.null(d))
stop("For argument centrotypes = 'medoids' d cannot be null")
if(!is.null(d)){
if(!is.matrix(d)){
d<-as.matrix(d)
}
row.names(d)<-row.names(x)
}
if(is.null(dim(x))){
dim(x)<-c(length(x),1)
}
n <- nrow(x)
g <- max(clall[,1])
Hart <- (wgss(x,clall[,1],d,centrotypes)/wgss(x,clall[,2],d,centrotypes)-1)*(n-g-1)
return(cbind(Hart = Hart, wgss1 = wgss(x,clall[,1],d,centrotypes), wgss2 = wgss(x,clall[,2],d,centrotypes)))
}
CalcCVIsForAll <- function(Xt, hp.vals, clust.mat, methods = c("Sil", "DB", "DBstar", "Gap", "Hart"), hp.name = "K.init"){
index.mat <- cbind(hp = hp.vals)
colnames(index.mat) <- hp.name
if ("DB" %in% methods){
DB <- apply(clust.mat, 2, function(Cs) index.DB(Xt, Cs, p=2,q=1)$DB)
index.mat <- cbind(index.mat, DB)
}
if ("DBstar" %in% methods){
DBstar <- apply(clust.mat, 2, function(Cs) index.DBstar(Xt, Cs))
index.mat <- cbind(index.mat, DBstar)
}
if ("Sil" %in% methods){
dist.Xt <- dist(Xt)
Sil <- apply(clust.mat, 2, function(Cs) index.S(dist.Xt, Cs))
index.mat <- cbind(index.mat, Sil)
}
if ("Gap" %in% methods){
if (ncol(clust.mat) == 1){
stop("Gap statistic requires more than one hp value")
} else {
Gap.stats <- do.call(rbind, lapply(1:(ncol(clust.mat) - 1), function(k)
index.Gap(Xt, cbind(clust.mat[, k], clust.mat[, k + 1]), method = "centroid")))
Gap.stats <- rbind(Gap.stats,
index.Gap(Xt, cbind(clust.mat[, ncol(clust.mat)], clust.mat[, ncol(clust.mat)]), method = "centroid"))
index.mat <- cbind(index.mat, Gap.stats)
}
}
if ("Hart" %in% methods){
Hart <- do.call(rbind, lapply(1:(ncol(clust.mat) - 1), function(k)
index.H(Xt, cbind(clust.mat[, k], clust.mat[, k + 1]))))
Hart <- rbind(Hart, NA)
index.mat <- cbind(index.mat, Hart)
}
return(index.mat)
}
index.mat <- CalcCVIsForAll(Xt, prop.vals.eta.max, clust.mat, CVI.methods, hp.name = "prop.eta.max")
decision.mat <- do.call(rbind, lapply(1:length(CVI.methods), function(CVI.index)
GetBestHPSingleIndex(index.mat,
CVI.name = CVI.methods[CVI.index],
decision.rule = decision.rules[CVI.index],
hp.name = "prop.eta.max")))
decisions.by.K[[K.index]] <- cbind.data.frame(K.init = K.vals[K.index], decision.mat)
K.vals <- sort(unique(res.AdaCLV$hp[, "K.init"]))
n.K <- length(K.vals)
decisions.by.K <- list()
for (K.index in 1:n.K){
wh <- which(res.AdaCLV$hp[, "K.init"] == K.vals[K.index])
clust.mat <- sapply(wh, function(x) GetHardClusters(res.AdaCLV$output[[x]]$S))
prop.vals.eta.max <- sort(res.AdaCLV$hp[wh, "prop.eta.max"])
index.mat <- CalcCVIsForAll(Xt, prop.vals.eta.max, clust.mat, CVI.methods, hp.name = "prop.eta.max")
decision.mat <- do.call(rbind, lapply(1:length(CVI.methods), function(CVI.index)
GetBestHPSingleIndex(index.mat,
CVI.name = CVI.methods[CVI.index],
decision.rule = decision.rules[CVI.index],
hp.name = "prop.eta.max")))
decisions.by.K[[K.index]] <- cbind.data.frame(K.init = K.vals[K.index], decision.mat)
}
decisions2 <- do.call(rbind, decisions.by.K)
decisions2
sub <- decisions2[which(decisions$CVI.name == "Hart"), ]
wh <- which(res.AdaCLV$hp[, "K.init"] == sub[hp.index, "K.init"] & res.AdaCLV$hp[, "prop.max.eta"] == sub[hp.index, "prop.max.eta"])
hp.index <- 1
wh <- which(res.AdaCLV$hp[, "K.init"] == sub[hp.index, "K.init"] &
res.AdaCLV$hp[, "prop.max.eta"] == sub[hp.index, "prop.max.eta"])
res.AdaCLV$hp
wh <- which(res.AdaCLV$hp[, "K.init"] == sub[hp.index, "K.init"] &
res.AdaCLV$hp[, "prop.eta.max"] == sub[hp.index, "prop.eta.max"])
S <- res.AdaCLV$output[[wh]]$S
PlotS(S, ylab = "Membership Degree", yaxt = "s")
sub <- decisions2[which(decisions$CVI.name == "Hart"), ]
for (hp.index in 1:nrow(sub)){
wh <- which(res.AdaCLV$hp[, "K.init"] == sub[hp.index, "K.init"] &
res.AdaCLV$hp[, "prop.eta.max"] == sub[hp.index, "prop.eta.max"])
S <- res.AdaCLV$output[[wh]]$S
#plot.title <- bquote(eta == .(eta.val) ~ ", " ~ K[init] == .(K.init))
PlotS(S, ylab = "Membership Degree", yaxt = "s")
}
hp.index
wh <- which(res.AdaCLV$hp[, "K.init"] == sub[hp.index, "K.init"] &
res.AdaCLV$hp[, "prop.eta.max"] == sub[hp.index, "prop.eta.max"])
S <- res.AdaCLV$output[[wh]]$S
wh
sub[hp.index, "K.init"]
sub
sub <- decisions2[which(decisions2$CVI.name == "Hart"), ]
sub
for (hp.index in 1:nrow(sub)){
wh <- which(res.AdaCLV$hp[, "K.init"] == sub[hp.index, "K.init"] &
res.AdaCLV$hp[, "prop.eta.max"] == sub[hp.index, "prop.eta.max"])
S <- res.AdaCLV$output[[wh]]$S
#plot.title <- bquote(eta == .(eta.val) ~ ", " ~ K[init] == .(K.init))
PlotS(S, ylab = "Membership Degree", yaxt = "s")
}
dev.off()
for (hp.index in 1:nrow(sub)){
wh <- which(res.AdaCLV$hp[, "K.init"] == sub[hp.index, "K.init"] &
res.AdaCLV$hp[, "prop.eta.max"] == sub[hp.index, "prop.eta.max"])
S <- res.AdaCLV$output[[wh]]$S
#plot.title <- bquote(eta == .(eta.val) ~ ", " ~ K[init] == .(K.init))
PlotS(S, ylab = "Membership Degree", yaxt = "s")
}
sub
sub <- decisions2[which(decisions2$CVI.name == "Sil"), ]
sub
sub <- decisions2[which(decisions2$CVI.name == "DBstar"), ]
sub
sub <- decisions2[which(decisions2$CVI.name == "DB"), ]
sub
